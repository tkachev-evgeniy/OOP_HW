Задание 3. 

класс карта 
поля:
полное название 
id карты (от 1 до 52)
масть
тип карты (девятка/ десятка/ валет)
кол-во очков
альтернативное кол-во очков (для туза). 

Класс Рука {
массив карт 
счетчик количества карт



Класс участник {
поля:
рука1
рука2 (для сплита)

методы: 
принять карту
показать карты
показать кол-во очков
}

Класс игрок - наследник участника. {
дополнительные поля:
ставка
банк
методы:
сделать ставку.
сделать обычный ход 
сделать сплит. 
принять выигрыш

}

Дилер - наследник участника. {
методы: 
раскрыть скрытую карту. 
}

// Если генерировать карту совсем случайно, то может случиться так что за один раунд выпадет больше одинаковых карт, чем используется колод. Поэтому потребуется какая-то защита. 
Класс колода
поля 
счетчик снятых карт
массив карт [52/104/156...]
int  массив колва карт с определенным id в колоде [52]// может быть это не пригодится, посмотрим походу.
массив int [52/104/156] // порядок карт в колоде, в неперемешанной значения последоватльно от 1 ... 52 (если колод несколько то после 52 снова 1 итд)
// я проверил, что в стандартной библиотеке есть функция shuffle, с помощью нее можно перемешать колоду, применив ее к массиву отвечающему за порядок.  

методы:
инициализировать колоду 
выдать карту сверху колоды. (возвращает объект класса карта, который игрок сможет принять). 

... что то это слишком громоздко.  

Можно проще.
Генерировать карты случайно, и накапливать количество сгенерированных карт с определенным id, если таких карт сгенерировалось больше чем было колод, сгенерировать заново. 
Если играть долго, то такой способ генерирования карты будет требовать больше действий от компа, т.к. вероятность наткнуться на уже выданную карту нарастает.
Но в Блэкджеке такая ситуация не грозит, т.к. за раунд раздается мало карт. 




 



